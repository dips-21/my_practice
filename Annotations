âœ… Component Annotations

Used to define Spring-managed beans in your application.
â— @Component â€“ General-purpose stereotype annotation. Spring detects it during
component scanning and manages its lifecycle as a bean.
â— @Service â€“ Specialization of @Component, intended for service-layer classes
containing business logic.
â— @Repository â€“ Indicates a data access object (DAO). Also enables exception
translation, converting DB-specific exceptions into Springâ€™s DataAccessException.
â— @Controller â€“ Marks a class as a web controller in Spring MVC. It handles HTTP
requests and returns views.
â— @RestController â€“ Combines @Controller and @ResponseBody, meaning every
method returns data (like JSON/XML) instead of a view.

âš™ï¸ Configuration Annotations

Define beans, control scanning, and manage environment setup.
â— @Configuration â€“ Marks a class that contains @Bean definitions. Spring uses it to
generate bean definitions and service requests.
â— @Bean â€“ Declares a bean to be managed by Spring. Used in methods inside a
@Configuration class.
â— @ComponentScan â€“ Tells Spring where to scan for components (classes annotated with
@Component, @Service, etc.).
â— @PropertySource â€“ Loads properties from a .properties file into Springâ€™s
Environment.
â— @Value â€“ Injects values from property files or expressions into fields or methods.
â— @Import â€“ Allows importing additional configuration classes.
â— @Profile â€“ Conditionally registers a bean based on the active Spring profile (dev,
test, prod, etc.).
â— @Conditional â€“ Register a bean only if a specific condition is met (e.g., presence of a
class or property).
â— @Lazy â€“ Defers bean initialization until it's actually needed. Great for performance
optimization.
â— @DependsOn â€“ Specifies bean initialization order by declaring dependencies.
â— @Primary â€“ When multiple beans of the same type exist, this one gets autowired by
default.
â— @Order â€“ Controls the order in which components are applied or loaded (e.g., filters or
interceptors).
â— @Scope â€“ Defines bean scope: singleton (default), prototype, request, session,
etc.
â— @Qualifier â€“ Helps resolve conflict when multiple beans of the same type are
available by specifying which one to inject.

ğŸ¤ Dependency Injection Annotations
â— @Autowired â€“ Automatically injects a dependency by type. Can be applied to
constructors, fields, or setters.
â— @Resource â€“ JSR-250 standard. Injects by name (first), then by type.
â— @Inject â€“ JSR-330 standard. Functions like @Autowired, but without Spring-specific
options like required=false.
â— @Required â€“ Ensures that a property must be set in Spring config. Throws error if not
initialized (now deprecated in favor of constructor injection).

ğŸš€ Spring Boot Annotations
â— @SpringBootApplication â€“ Combines @Configuration,
@EnableAutoConfiguration, and @ComponentScan in a single annotation to
bootstrap a Spring Boot app easily.
â— @EnableAutoConfiguration â€“ Tells Spring Boot to auto-configure your application
based on the dependencies present on the classpath.
â— @ConfigurationProperties â€“ Binds external configuration (like from
application.properties) to a POJO and validates them using JSR-303/JSR-380.
â— @ConditionalOnClass â€“ Loads a bean or configuration only if a specified class is
available in the classpath.
â— @ConditionalOnMissingClass â€“ Opposite of @ConditionalOnClass; activates if
the class is not present.
â— @ConditionalOnBean â€“ Loads configuration or beans only if a certain bean exists.
â— @ConditionalOnMissingBean â€“ Loads the bean only if the specified bean is not
present in the context.
â— @ConditionalOnProperty â€“ Activates beans/config based on a propertyâ€™s presence
and value.
â— @EnableConfigurationProperties â€“ Enables support for
@ConfigurationProperties-annotated beans.
â— @ConstructorBinding â€“Indicates that configuration properties should be bound using
the constructor instead of setters.
â— @ConfigurationPropertiesScan â€“ Automatically scans for
@ConfigurationProperties annotated beans.

ğŸŒ Spring MVC Annotations
â— @RequestMapping â€“ Maps HTTP requests to handler methods; can be used at class or
method level.
â— @GetMapping / @PostMapping / @PutMapping / @DeleteMapping /
@PatchMapping â€“ Shorthand for @RequestMapping for specific HTTP methods.
â— @PathVariable â€“Binds a URI template variable (e.g., /users/{id}) to a method
parameter.
â— @RequestParam â€“ Binds a request parameter (e.g., ?name=John) to a method
parameter.
â— @RequestBody â€“ Automatically deserializes JSON/XML request body into a Java
object.
â— @ResponseBody â€“ Serializes the return value of a method directly into the response
body (often JSON).
â— @ResponseStatus â€“ Specifies the HTTP status code returned from a method or
exception.
â— @ExceptionHandle â€“ Defines a method to handle exceptions thrown by controller
methods.
â— @ControllerAdvice â€“ Centralized error handling for all controllers in the application.
â— @RestControllerAdvice â€“ Combines @ControllerAdvice with @ResponseBody
for REST APIs.
â— @SessionAttributes â€“ Declares session-scoped model attributes.
â— @ModelAttribute â€“ Binds a method parameter or return value to a model attribute, or
initializes it before a controller method.
â— @InitBinder â€“ Initializes data binders for specific fields or parameter types.
â— @CookieValue â€“ Binds method parameters to HTTP cookie values.
â— @RequestHeader â€“ Binds method parameters to HTTP header values.
â— @CrossOrigin â€“ Enables CORS on handler methods or controller classes.

ğŸ” Spring Security Annotations

â— @EnableWebSecurity â€“ Enables Spring Securityâ€™s web security support and provides
a configuration hook for customizing security behavior.
â— @Secured â€“ Restricts access to a method by specifying required roles (e.g.,
@Secured("ROLE_ADMIN")).
â— @PreAuthorize â€“ Checks authorization before method execution using SpEL (Spring
Expression Language). Example: @PreAuthorize("hasRole('ADMIN')").
â— @PostAuthorize â€“ Runs after method execution to perform authorization checks on
the returned object.
â— @RolesAllowed â€“ Standard Java (JSR-250) way to define allowed roles for accessing
a method.
â— @PreFilter â€“ Filters elements of a collection before the method is executed, based on
a SpEL condition.
â— @PostFilter â€“ Filters the returned collection based on a SpEL expression after
method execution.
â— @AuthenticationPrincipal â€“ Injects the current authenticated principal (user) into
a controller method.
â— @CurrentSecurityContext â€“ Provides access to the Spring Security context within
methods.
â— @EnableGlobalMethodSecurity â€“ Enables method-level security annotations like
@PreAuthorize, @Secured, etc.
â— @EnableGlobalAuthentication â€“ Allows global configuration of authentication
settings (used internally by Spring).

ğŸ’¾ Spring Data / JPA Annotations

â— @Entity â€“ Marks a class as a persistent JPA entity, mapped to a database table.
â— @Table â€“ Specifies the database table name and attributes for the entity.
â— @Id â€“ Indicates the primary key of an entity.
â— @GeneratedValue â€“ Specifies how the primary key is generated (auto-increment,
UUID, etc.).
â— @Column â€“ Maps a field to a specific database column with optional constraints.
â— @Transient â€“ Prevents a field from being persisted in the database.
â— @Temporal â€“ Specifies the precision (DATE, TIME, TIMESTAMP) for date/time fields.
â— @Enumerated â€“ Defines how enum fields are persisted (as a string or ordinal).
â— @Lob â€“ Maps a field to a large object column (e.g., BLOB or CLOB).
â— @OneToOne / @OneToMany / @ManyToOne / @ManyToMany â€“ Define relationships
between entities.
â— @JoinColumn â€“ Specifies the foreign key column in relationships.
â— @JoinTable â€“ Defines a join table for many-to-many associations.
â— @Query â€“ Writes custom JPQL/SQL queries directly in repository interfaces.
â— @NamedQuery â€“ Declares a named JPQL query at the entity level.
â— @Modifying â€“ Marks a query method that changes the database state
(insert/update/delete).
â— @Transactional â€“ Defines transactional boundaries; can be used at method or class
level.
â— @NoRepositoryBean â€“ Indicates that the interface is not to be instantiated as a
repository bean.
â— @Param â€“ Names parameters used in @Query statements.
â— @EntityListeners â€“ Specifies entity lifecycle event listeners.
â— @CreatedDate / @LastModifiedDate â€“ Auto-fill fields with creation and last
modification timestamps.
â— @CreatedBy / @LastModifiedBy â€“ Auto-fill fields with user info when creating or
modifying an entity.

Spring Repository Annotations
â— @Repository â€“ Marks a class as a Data Access Object (DAO). It is a specialization of
@Component and is automatically detected during component scanning. Also, it enables
automatic translation of persistence-related exceptions into Spring's
DataAccessException.
â— @Query â€“ Used in Spring Data repositories to define custom JPQL or native SQL
queries directly on repository methods.
â— @Modifying â€“ Applied to repository methods that perform modifying queries (such as
UPDATE or DELETE). Must be used along with @Query.
â— @NoRepositoryBean â€“ Indicates that a repository interface should not be instantiated
directly. Useful when defining base repository interfaces that other interfaces will extend.
â— @Param â€“ Used to name parameters in a custom @Query so they can be referred to by
name in the query.
â— @EnableJpaRepositories â€“ Enables scanning for Spring Data JPA repositories and
configures them.

Spring Transaction Annotations
â— @Transactional â€“ Declares that a method or class should be executed within a
transaction. If an exception is thrown, the transaction can be rolled back automatically.
You can apply it at the class level (applies to all methods) or method level individually.
Key attributes:
â—‹ propagation: Determines how transactions relate (e.g., REQUIRED,
REQUIRES_NEW).
â—‹ isolation: Defines the isolation level of the transaction (e.g.,
READ_COMMITTED).
â—‹ readOnly: Marks the transaction as read-only.
â—‹ rollbackFor: Specifies which exceptions trigger a rollback.
â— @EnableTransactionManagement â€“ Enables Springâ€™s annotation-driven transaction
management. Required for @Transactional to work unless you're using Spring Boot
(which auto-enables it).
â— @Rollback (test-specific) â€“ Used in test classes to indicate whether the transaction
should roll back after the test.
â— @Commit (test-specific) â€“ Overrides the default rollback behavior for a test method and
forces a commit instead.

ğŸ’¾ Spring Cache Annotations

â— @EnableCaching: Enables annotation-driven cache management.
â— @Cacheable: Caches the result of a method call based on parameters.
â— @CachePut: Updates the cache without interfering with the method execution.
â— @CacheEvict: Removes entries from the cache.
â— @Caching: Groups multiple caching annotations on the same method.
â— @CacheConfig: Provides common cache settings for all methods in a class.

ğŸ§ª Spring Testing Annotations

â— @SpringBootTest â€“ Loads the full application context for integration testing.
â— @WebMvcTest â€“ Loads only the web layer (controllers) for focused tests.
â— @DataJpaTest â€“ Sets up JPA repositories for testing with in-memory DB.
â— @MockBean â€“ Adds a Mockito mock of a bean into the Spring application context.
â— @SpyBean â€“ Adds a Mockito spy of a bean into the context to verify interactions.
â— @ContextConfiguration â€“ Customizes the ApplicationContext for tests.
â— @ActiveProfiles â€“ Activates specific Spring profiles during test execution.
â— @TestPropertySource â€“ Adds specific property files or inlined properties for tests.
â— @DirtiesContext â€“ Marks the ApplicationContext as dirty, forcing it to reload for the
next test.
â— @Sql â€“ Executes SQL scripts before or after tests to set up or tear down data.
â— @Rollback â€“ Indicates that a test transaction should be rolled back after the test.
â— @Commit â€“ Forces a test transaction to commit instead of rolling back.
â— @TestConfiguration â€“ Declares test-specific configuration beans (similar to
@Configuration).

â˜ï¸ Spring Cloud Annotations
These annotations help in building microservices using Spring Cloud components like service
discovery, config server, load balancing, API gateway, etc.
â— @EnableDiscoveryClient â€“ Enables the service to register with a service discovery
system (like Eureka, Consul, or Zookeeper). It makes the app discoverable by other
services.
â— @EnableEurekaClient â€“ Specifically enables Eureka-based service registration. Itâ€™s a
more specific form of @EnableDiscoveryClient and ties the service to the Netflix
Eureka registry.
â— @EnableCircuitBreaker â€“ Enables Circuit Breaker pattern support (Hystrix or
Resilience4j) for fault tolerance. It automatically stops calling a failing service and
provides fallback logic.
â— @EnableConfigServer â€“ Turns your application into a centralized configuration
server, allowing other services to fetch their config properties from a central location
(typically via Git).
â— @EnableFeignClients â€“ Enables the use of Feign clients, which are declarative
REST clients. It automatically generates REST client implementations from annotated
interfaces.
â— @FeignClient â€“ Declares an interface as a Feign client. It simplifies calling REST
services using Java method invocations instead of writing boilerplate code using
RestTemplate.
â— @HystrixCommand â€“ Wraps a method with circuit breaker logic. If the method fails or
times out, a fallback method is triggered instead (deprecated in favor of Resilience4j).
â— @LoadBalanced â€“ When placed on a RestTemplate bean, enables client-side load
balancing. It allows service-to-service communication using the service name rather than
hardcoded URLs.
â— @EnableZuulProxy â€“ Enables Zuul as an API Gateway. It provides dynamic routing,
monitoring, resiliency, and security to your microservices architecture.
â— @EnableResourceServer â€“ Marks a microservice as a protected resource server that
requires OAuth2 access tokens for access.
â— @EnableAuthorizationServer â€“ Enables OAuth2 authorization server capabilities,
allowing the app to issue access tokens to clients.

ğŸŒ€ AOP (Aspect-Oriented Programming) Annotations
AOP in Spring lets you separate cross-cutting concerns (like logging, security, transactions)
from business logic using aspects.
â— @EnableAspectJAutoProxy â€“ Enables support for handling components marked with
@Aspect. It allows Spring to auto-detect and apply AOP proxies using AspectJ-style
annotations.
â— @Aspect â€“ Marks a class as an aspect. The class can contain advice (code to be
executed) and pointcuts (where to execute that code).
â— @Pointcut â€“ Defines a reusable expression that matches join points (places in the
code where aspects should be applied). Used to target specific methods or packages.
â— @Before â€“ Declares advice that runs before the matched method execution. Great for
logging, authentication, or pre-checks.
â— @After â€“ Declares advice that runs after the matched method, regardless of its
outcome (success or exception).
â— @AfterReturning â€“ Runs after a method executes successfully. It can also capture
and manipulate the return value.
â— @AfterThrowing â€“ Runs only if the target method throws an exception. Useful for
error logging or alerting.
â— @Around â€“ The most powerful advice type. It wraps the method executionâ€”can execute
code before and after, and even skip method execution or modify arguments and
results.

â±ï¸ Asynchronous and Scheduling Annotations
These annotations help in executing tasks asynchronously or on a schedule without blocking
the main thread.
â— @EnableAsync â€“ Enables Spring's asynchronous method execution. When used, any
method annotated with @Async will run in a separate thread.
â— @Async â€“ Marks a method to be executed asynchronously. This allows long-running
tasks (like sending emails or processing files) to run without blocking the caller.
â— @EnableScheduling â€“ Activates Spring's scheduled task execution capability. Without
this, @Scheduled wonâ€™t work.
â— @Scheduled â€“ Schedules a method to run at fixed intervals or cron expressions. Can
be used for tasks like periodic cleanups or data syncing.
Example: @Scheduled(fixedRate = 5000) or @Scheduled(cron = "0 0 * *
* *")
â— @Schedules â€“ Allows multiple @Scheduled annotations on a single method, useful
when the same method needs to run on different schedules.

ğŸ“¬ Messaging Annotations
Spring provides support for messaging systems like JMS, RabbitMQ, and Kafka, and these
annotations help define listeners and message mapping logic.
General Messaging Annotations
â— @Payload â€“ Binds a method parameter to the message payload (the actual data).
Works in JMS, Kafka, and RabbitMQ.
â— @Header â€“ Binds a method parameter to a specific message header (like messageId,
correlationId, etc.).
â— @Headers â€“ Injects all message headers into a Map<String, Object> parameter for
inspection or logic.
â— @SendTo â€“ Specifies where the return value of a listener method should be sent. Used
to route responses in message-driven systems.
JMS (Java Message Service)
â— @EnableJms â€“ Enables JMS-related configuration and listener support in Spring
applications.
â— @JmsListener â€“ Marks a method as a JMS message listener that gets triggered when
a message arrives on a queue/topic.
RabbitMQ
â— @EnableRabbit â€“ Enables RabbitMQ listener support and message-driven POJO
configuration.
â— @RabbitListener â€“ Declares a method to listen for messages on RabbitMQ queues.
Kafka
â— @EnableKafka â€“ Enables Kafka listener support in Spring applications.
â— @KafkaListener â€“ Marks a method as a Kafka message listener for a topic or set of
topics.



20. What is the purpose of the @Transactional annotation in Spring Boot?
The @Transactional annotation in Spring Boot is used to define the transactional
behavior of a method or a class. Transactions ensure that a set of operations are
treated as a single unit of work, providing ACID (Atomicity, Consistency,
Isolation, Durability) properties.
By annotating a method or class with @Transactional , Spring Boot automatically
manages the transactional behavior, handling transaction demarcation,
propagation, and rollback based on the configured settings.
The @Transactional annotation can be placed at the method level, where it
defines that the method should be executed within a transactional context. It can
also be placed at the class level, where all public methods of that class become
transactional.
The purpose of the @Transactional annotation is to simplify transaction
management by providing a declarative way to define the transactional
boundaries. It allows developers to focus on the business logic without worrying
about the low-level transaction management details.